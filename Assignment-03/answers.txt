### QUESTION: What embeddings and vector store did you use and why? Explain your design decision in less than 10 sentences.
We used OpenAI's "text-embedding-ada-002" for embeddings and FAISS (Facebook AI Similarity Search) as our vector store. The "text-embedding-ada-002" model provides embeddings with high quality semantic understanding of academic and technical content, which is important for accurately representing SUTD's educational information. We have compared the performance of this model against the following other models namely: all-MiniLM-L6-v2, all-mpnet-base-v2, and text-embedding-3-small. Among the 4, text-embedding-ada-002 was able to perform the best (based on human judgement). It also integrates smoothly alongside the vector store chosen.
FAISS was our go-to choice because it efficiently handles nearest-neighbor searches in high-dimensional spaces, retrieves results quickly even from large collections, and keeps memory usage low through quantization. We have done research on other strategies such as Pinecone and Weaviate, but the ease of integration with FAISS utlimately helped us make our decision. Moreover, we have come across a lot of research in which FAISS was used, which proves its reliability.

We built a custom embeddings class that works with both OpenAI and local HuggingFace models, so switching between them is seamless while using the same interface. This setup delivers fast, accurate semantic search results while reliably keeping the vector store locally.
### QUESTION: What chunking method or strategy did you use? Why did you use this method. Explain your design decision in less than 10 sentences.
We designed a hierarchical chunking strategy that respects the natural flow of a document. First, we extract logical sections using markdown headers (h1-h6), turning each section into its own chunk with its heading, content, and useful metadata like title, URL, parent sections, and pillar/department information. To avoid fragmentation, we combine very short chunks (under 100 characters) with nearby related content, and for long chunks (over 1000 characters), we split them using a recursive approach that breaks at natural separators such as paragraphs or sentences. We also keep a 100-character overlap between chunks to maintain context. This way, each chunk remains a complete, meaningful unit, perfectly sized for embedding and retrieval.